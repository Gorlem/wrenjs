<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: wren.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: wren.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module Wren
 */

import Module from './generated/libwren.js';
import {Configuration} from './configuration.js';

/*
* 'C' represents our connection to the C API, through emscripten's ccall function.
* We predefine ccall to throw an error, and override it once emscripten is ready.
*
* That way we can throw a useful error if needed.
*/
let C = {
    ccall: function(method) {
        throw('WrenJS is not ready! Wait for "Wren.ready" to resolve.');
    }
};

/**
* A Promise that resolves once WrenJS is ready to use.
*/
export var ready = Module().then( function(context) {
    C = context;
});

/**
* Get the current wren version number.
*
* Can be used to range checks over versions.
* @return {number}
*/
export function getVersionNumber() {
  let result = C.ccall('wrenGetVersionNumber',
      'number',
      [], []
  );

  return result;
}

/**
* A single virtual machine for executing Wren code.
*
* Wren has no global state, so all state stored by a running interpreter lives here.
*/
export class VM {

    /**
    * Creates a new Wren virtual machine using the given [configuration]. Wren
    * will copy the configuration data, so the argument passed to this can be
    * freed after calling this. If [configuration] is undefined, uses a default
    * configuration.
    */
    constructor(config) {
        // Replaces wrenInitConfiguration
        let default_config = {
            resolveModuleFn     : Configuration.defaultResolveModuleFn,
            loadModuleFn        : Configuration.defaultLoadModuleFn,
            bindForeignMethodFn : Configuration.defaultBindForeignMethodFn,
            bindForeignClassFn  : Configuration.defaultBindForeignClassFn,
            writeFn             : Configuration.defaultWriteFn,
            errorFn             : Configuration.defaultErrorFn
        }
        this.config = Object.assign(default_config, config);

        this._pointer = C.ccall('shimNewVM',
          'number',
          [],[]
        );

        VM[this._pointer] = this;

        this._foreignClasses = {};
    }

    /*
    * The following methods are called from C, and should not be relied upon in
    * the JS context.
    * --------------------------------------------------------------------------
    */

    _loadModule(name) {
        return this.config.loadModuleFn(name);
    }

    _bindForeignMethod(module, className, isStatic, signature) {
        let method = this.config.bindForeignMethodFn(this, module, className,
          isStatic, signature
        );

        // This is the function we pass back to C.
        // C will pass this a pointer for the wren VM, and we need to get the
        // JS version to the JS function.
        let vm = this;
        return function(_) {
            method(vm);
        }
    }

    _bindForeignClass(module, className) {
        var methods =  this.config.bindForeignClassFn(this, module, className);

        // Similar to the bindForeignMethod fn above, C expects to pass these
        // a pointer to the VM, and we need to convert that to a JS Wren.VM
        let vm = this;
        return {
            allocate: function(_) {
                methods.allocate(vm);
            },
            finalize: function(_) {
                methods.finalize(vm);

                let pointer = C.ccall('wrenGetSlotForeign',
                  'number',
                  ['number', 'number'],
                  [this._pointer, 0]
                );

                delete this._foreignClasses[pointer];
            }
        }
    }

    _write(text) {
        this.config.writeFn(text);
    }

    _error(errorType, module, line, msg) {
        this.config.errorFn(errorType, module, line, msg);
    }

    /*
    * The following methods are implementations of the Wren C API, callable
    * from the JS context.
    * --------------------------------------------------------------------------
    */

    /**
    * Disposes of all resources is use by the VM.
    */
    free() {
        C.ccall('wrenFreeVM',
          null,
          ['number'],
          [this._pointer]
        );
        delete VM[this._pointer]
        this._pointer = undefined;
    }

    /**
    * Immediately run the garbage collector to free unused memory.
    */
    collectGarbage() {
        C.ccall('wrenCollectGarbage',
          null,
          ['number'],
          [this._pointer]
        );
    }

    /**
    * Runs [source], a string of Wren source code in a new fiber in [vm] in the
    * context of resolved [module].
    * @return {string} whether the result was a success or error.
    */
    interpret(module, src) {
        let r = C.ccall('wrenInterpret',
            'number',
            ['number', 'string', 'string'],
            [this._pointer, module, src]);

        let results = [
          'WREN_RESULT_SUCCESS',
          'WREN_RESULT_COMPILE_ERROR',
          'WREN_RESULT_RUNTIME_ERROR'
        ];

        return results[r];
    }

    /**
    * Creates a handle that can be used to invoke a method with [signature] on
    * using a receiver and arguments that are set up on the stack.
    *
    * This handle can be used repeatedly to directly invoke that method from JS
    * code using [call].
    *
    * When you are done with this handle, it must be released using
    * [releaseHandle].
    * @return {number} a handle for use with [VM.call].
    */
    makeCallHandle(signature) {
        let handle = C.ccall('wrenMakeCallHandle',
          'number',
          ['number', 'string'],
          [this._pointer, signature]
        );
        return handle;
    }

    /**
    * Calls [method], using the receiver and arguments previously set up on the
    * stack.
    *
    * [method] must have been created by a call to [makeCallHandle]. The
    * arguments to the method must be already on the stack. The receiver should be
    * in slot 0 with the remaining arguments following it, in order. It is an
    * error if the number of arguments provided does not match the method's
    * signature.
    *
    * After this returns, you can access the return value from slot 0 on the stack.
    * @return {string} whether the result was a success or error.
    */
    call(method) {
        let r = C.ccall('wrenCall',
          'number',
          ['number', 'number'],
          [this._pointer, method]
        );

        let results = [
          'WREN_RESULT_SUCCESS',
          'WREN_RESULT_COMPILE_ERROR',
          'WREN_RESULT_RUNTIME_ERROR'
        ]; // TODO: Pull out into an enum.

        return results[r];
    }

    /**
    * Releases the reference stored in [handle]. After calling this, [handle] can
    * no longer be used.
    */
    releaseHandle(handle) {
        C.ccall('wrenReleaseHandle',
          null,
          ['number', 'number'],
          [this._pointer, 'handle']
        );
    }

    /**
    * Returns the number of slots available to the current foreign method.
    * @return {number} the number of slots.
    */
    getSlotCount() {
        let count = C.ccall('wrenGetSlotCount',
          'number',
          ['number'],
          [this._pointer]
        );
        return count;
    }

    /**
    * Ensures that the foreign method stack has at least [numSlots] available for
    * use, growing the stack if needed.
    *
    * Does not shrink the stack if it has more than enough slots.
    *
    * It is an error to call this from a finalizer.
    */
    ensureSlots(numSlots) {
        C.ccall('wrenEnsureSlots',
          null,
          ['number', 'number'],
          [this._pointer, numSlots]
        );
    }

    /**
    * Gets the type of the object in [slot].
    * @return {string} the type of the object.
    */
    getSlotType(slot) {
        let t = C.ccall('wrenGetSlotType',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );

        let types = [
          'WREN_TYPE_BOOL',
          'WREN_TYPE_NUM',
          'WREN_TYPE_FOREIGN',
          'WREN_TYPE_LIST',
          'WREN_TYPE_MAP',
          'WREN_TYPE_NULL',
          'WREN_TYPE_STRING',
          'WREN_TYPE_UNKNOWN'
        ]; // TODO: pull out into an enum.

        return types[t];
    }

    /**
    * Reads a boolean value from [slot].
    *
    * It is an error to call this if the slot does not contain a boolean value.
    * @return {boolean}
    */
    getSlotBool(slot) {
        let boolean = C.ccall('wrenGetSlotBool',
          'boolean',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return boolean;
    }

    /**
    * Reads a byte array from [slot].
    *
    * The memory for the returned string is owned by Wren. You can inspect it
    * while in your foreign method, but cannot keep a pointer to it after the
    * function returns, since the garbage collector may reclaim it.
    *
    * Returns a pointer to the first byte of the array and fill [length] with the
    * number of bytes in the array. TODO: does it?
    *
    * It is an error to call this if the slot does not contain a string.
    * @return {string} the bytes as a string.
    */
    getSlotBytes(slot, length) {
        let bytes = C.ccall('wrenGetSlotBytes',
          'string',
          ['number', 'number', 'number'],
          [this._pointer, slot, length]
        );
        return bytes;
    }

    /**
    * Reads a number from [slot].
    *
    * It is an error to call this if the slot does not contain a number.
    * @return {number}
    */
    getSlotDouble(slot) {
        let double = C.ccall('wrenGetSlotDouble',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return double;
    }

    /**
    * Reads a foreign object from [slot] and returns a pointer to the foreign data
    * stored with it.
    *
    * It is an error to call this if the slot does not contain an instance of a
    * foreign class.
    * @return {Object}
    */
    getSlotForeign(slot) {
        let pointer = C.ccall('wrenGetSlotForeign',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );

        return this._foreignClasses[pointer];
    }

    /**
    * Reads a string from [slot].
    *
    * The memory for the returned string is owned by Wren. You can inspect it
    * while in your foreign method, but cannot keep a pointer to it after the
    * function returns, since the garbage collector may reclaim it.
    * TODO: Is it?
    *
    * It is an error to call this if the slot does not contain a string.
    * @return {string}
    */
    getSlotString(slot) {
        let string = C.ccall('wrenGetSlotString',
          'string',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return string;
    }

    /**
    * Creates a handle for the value stored in [slot].
    *
    * This will prevent the object that is referred to from being garbage collected
    * until the handle is released by calling [releaseHandle()].
    * @return {number} a handle for use with [VM.call].
    */
    getSlotHandle(slot) {
        let handle = C.ccall('wrenGetSlotHandle',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return handle;
    }

    /**
    * Stores the boolean [value] in [slot].
    */
    setSlotBool(slot, value) {
        C.ccall('wrenSetSlotBool',
          null,
          ['number', 'number', 'boolean'],
          [this._pointer, slot, value]
        );
    }

    /**
    * Stores the array [length] of [bytes] in [slot].
    *
    * The bytes are copied to a new string within Wren's heap, so you can free
    * memory used by them after this is called.
    */
    setSlotBytes(slot, bytes, length) {
        C.ccall('wrenSetSlotBytes',
          null,
          ['number', 'number', 'string', 'number'],
          [this._pointer, slot, bytes, length]
        );
    }

    /**
    * Stores the numeric [value] in [slot].
    */
    setSlotDouble(slot, value) {
        C.ccall('wrenSetSlotDouble',
          null,
          ['number', 'number', 'number'],
          [this._pointer, slot, value]
        );
    }

    /**
    * Creates a new instance of the foreign class stored in [classSlot] with [size]
    * bytes of raw storage and places the resulting object in [slot].
    *
    * This does not invoke the foreign class's constructor on the new instance. If
    * you need that to happen, call the constructor from Wren, which will then
    * call the allocator foreign method. In there, call this to create the object
    * and then the constructor will be invoked when the allocator returns.
    *
    * Returns a pointer to the foreign object's data. TODO: false.
    */
    setSlotNewForeign(slot, classSlot, foreignObject) {
        let pointer = C.ccall('wrenSetSlotNewForeign',
          'number',
          ['number', 'number', 'number', 'number'],
          [this._pointer, slot, classSlot, 0]
        );

        this._foreignClasses[pointer] = foreignObject;

        return foreignObject;
    }

    /**
    * Stores a new empty list in [slot].
    */
    setSlotNewList(slot) {
        C.ccall('wrenSetSlotNewList',
          null,
          ['number', 'number'],
          [this._pointer, slot]
        );
    }

    /**
    * Stores a new empty map in [slot].
    */
    setSlotNewMap(slot) {
        C.ccall('wrenSetSlotNewMap',
          null,
          ['number', 'number'],
          [this._pointer, slot]
        );
    }

    /**
    * Stores null in [slot].
    */
    setSlotNull(slot) {
        C.ccall('wrenSetSlotNull',
          null,
          ['number', 'number'],
          [this._pointer, slot]
        );
    }

    /**
    * Stores the string [text] in [slot].
    *
    * The [text] is copied to a new string within Wren's heap, so you can free
    * memory used by it after this is called. The length is calculated using
    * [strlen()]. If the string may contain any null bytes in the middle, then you
    * should use [setSlotBytes()] instead.
    */
    setSlotString(slot, text) {
        C.ccall('wrenSetSlotString',
          null,
          ['number', 'number', 'string'],
          [this._pointer, slot, text]
        );
    }

    /**
    * Stores the value captured in [handle] in [slot].
    *
    * This does not release the handle for the value.
    */
    setSlotHandle(slot, handle) {
        C.ccall('wrenSetSlotHandle',
          null,
          ['number', 'number', 'number'],
          [this._pointer, slot, handle]
        );
    }

    /**
    * Returns the number of elements in the list stored in [slot].
    * @return {number}
    */
    getListCount(slot) {
        let count = C.ccall('wrenGetListCount',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return count;
    }

    /**
    * Reads element [index] from the list in [listSlot] and stores it in
    * [elementSlot].
    */
    getListElement(listSlot, index, elementSlot) {
        C.ccall('wrenGetListElement',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, listSlot, index, elementSlot]
        );
    }

    /**
    * Sets the value stored at [index] in the list at [listSlot],
    * to the value from [elementSlot].
    */
    setListElement(listSlot, index, elementSlot) {
        C.ccall('wrenSetListElement',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, listSlot, index, elementSlot]
        );
    }

    /**
    * Takes the value stored at [elementSlot] and inserts it into the list stored
    * at [listSlot] at [index].
    *
    * As in Wren, negative indexes can be used to insert from the end. To append
    * an element, use `-1` for the index.
    */
    insertInList(listSlot, index, elementSlot) {
        C.ccall('wrenInsertInList',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, listSlot, index, elementSlot]
        );
    }

    /**
    * Returns the number of entries in the map stored in [slot].
    * @return {number}
    */
    getMapCount(slot) {
        let count = C.ccall('wrenGetMapCount',
          'number',
          ['number', 'number'],
          [this._pointer, slot]
        );
        return count;
    }

    /**
    * Returns true if the key in [keySlot] is found in the map placed in [mapSlot].
    * @return {boolean}
    */
    getMapContainsKey(mapSlot, keySlot) {
        let boolean = C.ccall('wrenGetMapContainsKey',
          'boolean',
          ['number', 'number', 'number'],
          [this._pointer, mapSlot, keySlot]
        );
        return boolean;
    }

    /**
    * Retrieves a value with the key in [keySlot] from the map in [mapSlot] and
    * stores it in [valueSlot].
    */
    getMapValue(mapSlot, keySlot, valueSlot) {
        C.ccall('wrenGetMapValue',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, mapSlot, keySlot, valueSlot]
        );
    }

    /**
    * Takes the value stored at [valueSlot] and inserts it into the map stored
    * at [mapSlot] with key [keySlot].
    */
    setMapValue(mapSlot, keySlot, valueSlot) {
        C.ccall('wrenSetMapValue',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, mapSlot, keySlot, valueSlot]
        );
    }

    /**
    * Removes a value from the map in [mapSlot], with the key from [keySlot],
    * and place it in [removedValueSlot]. If not found, [removedValueSlot] is
    * set to null, the same behaviour as the Wren Map API.
    */
    removeMapValue(mapSlot, keySlot, removedValueSlot) {
        C.ccall('wrenRemoveMapValue',
          null,
          ['number', 'number', 'number', 'number'],
          [this._pointer, mapSlot, keySlot, removedValueSlot]
        );
    }

    /**
    * Looks up the top level variable with [name] in resolved [module] and stores
    * it in [slot].
    */
    getVariable(module, name, slot) {
        C.ccall('wrenGetVariable',
          null,
          ['number', 'string', 'string', 'number'],
          [this._pointer, module, name, slot]
        );
    }

    /**
    * Looks up the top level variable with [name] in resolved [module],
    * returns false if not found. The module must be imported at the time,
    * use wrenHasModule to ensure that before calling.
    * @return {boolean}
    */
    hasVariable(module, name) {
        let boolean = C.ccall('wrenHasVariable',
          'boolean',
          ['number', 'string', 'string'],
          [this._pointer, module, name]
        );
        return boolean;
    }

    /**
    * Returns true if [module] has been imported/resolved before, false if not.
    * @return {boolean}
    */
    hasModule(module) {
        let boolean = C.ccall('wrenHasModule',
          'boolean',
          ['number', 'string'],
          [this._pointer, module]
        );
        return boolean;
    }

    /**
    * Sets the current fiber to be aborted, and uses the value in [slot] as the
    * runtime error object.
    */
    abortFiber(slot) {
        C.ccall('wrenAbortFiber',
          null,
          ['number', 'number'],
          [this._pointer, slot]
        );
    }

    // The following APIs are not implemented.
    //getUserData() {}
    //setUserData(userData) {}
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Wren.html">Wren</a></li></ul><h3>Classes</h3><ul><li><a href="module-Wren.VM.html">VM</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Sat Jun 19 2021 19:42:09 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
